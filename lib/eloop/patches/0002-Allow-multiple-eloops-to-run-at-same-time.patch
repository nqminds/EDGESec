From f03a7d46df0966fc764c7fa97130cebedb95ed7c Mon Sep 17 00:00:00 2001
From: Alois Klink <alois@nquiringminds.com>
Date: Tue, 6 Sep 2022 18:28:04 +0100
Subject: [PATCH 2/3] Allow multiple eloops to run at same time

Passes the `eloop_data eloop` variable as a parameter to all
eloop functions, instead of using a static/shared eloop variable.

Unfortunately, this breaks signals/signal catching, since in C,
closure functions do not exist.

Adapted from commit
https://github.com/nqminds/edgesec/commit/09d9bed9d31496d62da44d37aef37cec97ff5b4e
---
 src/utils/eloop.c | 634 ++++++++++++++++++----------------------------
 src/utils/eloop.h | 266 +++++++++++--------
 2 files changed, 414 insertions(+), 486 deletions(-)

diff --git a/src/utils/eloop.c b/src/utils/eloop.c
index 66e05d1..4035a9a 100644
--- a/src/utils/eloop.c
+++ b/src/utils/eloop.c
@@ -10,118 +10,15 @@
 #include <stdint.h>
 #include <stdlib.h>
 #include <assert.h>
-#include <signal.h>
 #include <sys/select.h>
 #include <errno.h>
 
-#include "trace.h"
-#include "list.h"
 // #include "common.h"
 #include "eloop.h"
+
 #include "src/utils/allocs.h"
 #include "src/utils/log.h"
 
-#if defined(CONFIG_ELOOP_POLL) && defined(CONFIG_ELOOP_EPOLL)
-#error Do not define both of poll and epoll
-#endif
-
-#if defined(CONFIG_ELOOP_POLL) && defined(CONFIG_ELOOP_KQUEUE)
-#error Do not define both of poll and kqueue
-#endif
-
-#if !defined(CONFIG_ELOOP_POLL) && !defined(CONFIG_ELOOP_EPOLL) && \
-    !defined(CONFIG_ELOOP_KQUEUE)
-#define CONFIG_ELOOP_SELECT
-#endif
-
-#ifdef CONFIG_ELOOP_POLL
-#include <poll.h>
-#endif /* CONFIG_ELOOP_POLL */
-
-#ifdef CONFIG_ELOOP_EPOLL
-#include <sys/epoll.h>
-#endif /* CONFIG_ELOOP_EPOLL */
-
-#ifdef CONFIG_ELOOP_KQUEUE
-#include <sys/event.h>
-#endif /* CONFIG_ELOOP_KQUEUE */
-
-struct eloop_sock {
-	int sock;
-	void *eloop_data;
-	void *user_data;
-	eloop_sock_handler handler;
-	WPA_TRACE_REF(eloop);
-	WPA_TRACE_REF(user);
-	WPA_TRACE_INFO
-};
-
-struct eloop_timeout {
-	struct dl_list list;
-	struct os_reltime time;
-	void *eloop_data;
-	void *user_data;
-	eloop_timeout_handler handler;
-	WPA_TRACE_REF(eloop);
-	WPA_TRACE_REF(user);
-	WPA_TRACE_INFO
-};
-
-struct eloop_signal {
-	int sig;
-	void *user_data;
-	eloop_signal_handler handler;
-	int signaled;
-};
-
-struct eloop_sock_table {
-	size_t count;
-	struct eloop_sock *table;
-	eloop_event_type type;
-	int changed;
-};
-
-struct eloop_data {
-	int max_sock;
-
-	size_t count; /* sum of all table counts */
-#ifdef CONFIG_ELOOP_POLL
-	size_t max_pollfd_map; /* number of pollfds_map currently allocated */
-	size_t max_poll_fds; /* number of pollfds currently allocated */
-	struct pollfd *pollfds;
-	struct pollfd **pollfds_map;
-#endif /* CONFIG_ELOOP_POLL */
-#if defined(CONFIG_ELOOP_EPOLL) || defined(CONFIG_ELOOP_KQUEUE)
-	int max_fd;
-	struct eloop_sock *fd_table;
-#endif /* CONFIG_ELOOP_EPOLL || CONFIG_ELOOP_KQUEUE */
-#ifdef CONFIG_ELOOP_EPOLL
-	int epollfd;
-	size_t epoll_max_event_num;
-	struct epoll_event *epoll_events;
-#endif /* CONFIG_ELOOP_EPOLL */
-#ifdef CONFIG_ELOOP_KQUEUE
-	int kqueuefd;
-	size_t kqueue_nevents;
-	struct kevent *kqueue_events;
-#endif /* CONFIG_ELOOP_KQUEUE */
-	struct eloop_sock_table readers;
-	struct eloop_sock_table writers;
-	struct eloop_sock_table exceptions;
-
-	struct dl_list timeout;
-
-	size_t signal_count;
-	struct eloop_signal *signals;
-	int signaled;
-	int pending_terminate;
-
-	int terminate;
-};
-
-static struct eloop_data eloop;
-
-
 #ifdef WPA_TRACE
 
 static void eloop_sigsegv_handler(int sig)
@@ -167,39 +64,50 @@ static void eloop_trace_sock_remove_ref(struct eloop_sock_table *table)
 #endif /* WPA_TRACE */
 
 
-int eloop_init(void)
+struct eloop_data *eloop_init(void)
 {
-	os_memset(&eloop, 0, sizeof(eloop));
-	dl_list_init(&eloop.timeout);
+	struct eloop_data *eloop = NULL;
+
+	if ((eloop = os_zalloc(sizeof(struct eloop_data))) == NULL) {
+		log_errno("os_zalloc");
+		return NULL;
+	}
+
+	dl_list_init(&eloop->timeout);
 #ifdef CONFIG_ELOOP_EPOLL
-	eloop.epollfd = epoll_create1(0);
-	if (eloop.epollfd < 0) {
+	eloop->epollfd = epoll_create1(0);
+	if (eloop->epollfd < 0) {
 		log_errno("eloop_init: epoll_create1 failed.");
-		return -1;
+		return NULL;
 	}
 #endif /* CONFIG_ELOOP_EPOLL */
 #ifdef CONFIG_ELOOP_KQUEUE
-	eloop.kqueuefd = kqueue();
-	if (eloop.kqueuefd < 0) {
+	eloop->kqueuefd = kqueue();
+	if (eloop->kqueuefd < 0) {
 		log_errno("eloop_init: kqueue failed");
-		return -1;
+		return NULL;
 	}
 #endif /* CONFIG_ELOOP_KQUEUE */
 #if defined(CONFIG_ELOOP_EPOLL) || defined(CONFIG_ELOOP_KQUEUE)
-	eloop.readers.type = EVENT_TYPE_READ;
-	eloop.writers.type = EVENT_TYPE_WRITE;
-	eloop.exceptions.type = EVENT_TYPE_EXCEPTION;
+	eloop->readers.type = EVENT_TYPE_READ;
+	eloop->writers.type = EVENT_TYPE_WRITE;
+	eloop->exceptions.type = EVENT_TYPE_EXCEPTION;
 #endif /* CONFIG_ELOOP_EPOLL || CONFIG_ELOOP_KQUEUE */
 #ifdef WPA_TRACE
 	signal(SIGSEGV, eloop_sigsegv_handler);
 #endif /* WPA_TRACE */
-	return 0;
+	return eloop;
 }
 
 
 #ifdef CONFIG_ELOOP_EPOLL
-static int eloop_sock_queue(int sock, eloop_event_type type)
+static int eloop_sock_queue(struct eloop_data *eloop, int sock,
+                            eloop_event_type type)
 {
+	if (eloop == NULL) {
+		log_error("eloop param is NULL");
+		return -1;
+	}
 	struct epoll_event ev;
 
 	os_memset(&ev, 0, sizeof(ev));
@@ -220,7 +128,7 @@ static int eloop_sock_queue(int sock, eloop_event_type type)
 		break;
 	}
 	ev.data.fd = sock;
-	if (epoll_ctl(eloop.epollfd, EPOLL_CTL_ADD, sock, &ev) < 0) {
+	if (epoll_ctl(eloop->epollfd, EPOLL_CTL_ADD, sock, &ev) < 0) {
 		log_errno("eloop_sock_queues: epoll_ctl(ADD) for fd=%d failed", sock);
 		return -1;
 	}
@@ -244,12 +152,13 @@ static short event_type_kevent_filter(eloop_event_type type)
 }
 
 
-static int eloop_sock_queue(int sock, eloop_event_type type)
+static int eloop_sock_queue(struct eloop_data *eloop, int sock,
+                            eloop_event_type type)
 {
 	struct kevent ke;
 
 	EV_SET(&ke, sock, event_type_kevent_filter(type), EV_ADD, 0, 0, 0);
-	if (kevent(eloop.kqueuefd, &ke, 1, NULL, 0, NULL) == -1) {
+	if (kevent(eloop->kqueuefd, &ke, 1, NULL, 0, NULL) == -1) {
 		log_errno("eloop_sock_queue: kevent(ADD) for fd=%d failed", sock);
 		return -1;
 	}
@@ -259,10 +168,15 @@ static int eloop_sock_queue(int sock, eloop_event_type type)
 #endif /* CONFIG_ELOOP_KQUEUE */
 
 
-static int eloop_sock_table_add_sock(struct eloop_sock_table *table,
-                                     int sock, eloop_sock_handler handler,
+static int eloop_sock_table_add_sock(struct eloop_data *eloop,
+                                     struct eloop_sock_table *table, int sock,
+                                     eloop_sock_handler handler,
                                      void *eloop_data, void *user_data)
 {
+	if (eloop == NULL) {
+		log_error("eloop param is NULL");
+		return -1;
+	}
 #ifdef CONFIG_ELOOP_EPOLL
 	struct epoll_event *temp_events;
 #endif /* CONFIG_ELOOP_EPOLL */
@@ -276,70 +190,70 @@ static int eloop_sock_table_add_sock(struct eloop_sock_table *table,
 	struct eloop_sock *tmp;
 	int new_max_sock;
 
-	if (sock > eloop.max_sock)
+	if (sock > eloop->max_sock)
 		new_max_sock = sock;
 	else
-		new_max_sock = eloop.max_sock;
+		new_max_sock = eloop->max_sock;
 
 	if (table == NULL)
 		return -1;
 
 #ifdef CONFIG_ELOOP_POLL
-	if ((size_t) new_max_sock >= eloop.max_pollfd_map) {
+	if ((size_t) new_max_sock >= eloop->max_pollfd_map) {
 		struct pollfd **nmap;
-		nmap = os_realloc_array(eloop.pollfds_map, new_max_sock + 50,
+		nmap = os_realloc_array(eloop->pollfds_map, new_max_sock + 50,
 					sizeof(struct pollfd *));
 		if (nmap == NULL)
 			return -1;
 
-		eloop.max_pollfd_map = new_max_sock + 50;
-		eloop.pollfds_map = nmap;
+		eloop->max_pollfd_map = new_max_sock + 50;
+		eloop->pollfds_map = nmap;
 	}
 
-	if (eloop.count + 1 > eloop.max_poll_fds) {
+	if (eloop->count + 1 > eloop->max_poll_fds) {
 		struct pollfd *n;
-		size_t nmax = eloop.count + 1 + 50;
+		size_t nmax = eloop->count + 1 + 50;
 
-		n = os_realloc_array(eloop.pollfds, nmax,
+		n = os_realloc_array(eloop->pollfds, nmax,
 				     sizeof(struct pollfd));
 		if (n == NULL)
 			return -1;
 
-		eloop.max_poll_fds = nmax;
-		eloop.pollfds = n;
+		eloop->max_poll_fds = nmax;
+		eloop->pollfds = n;
 	}
 #endif /* CONFIG_ELOOP_POLL */
 #if defined(CONFIG_ELOOP_EPOLL) || defined(CONFIG_ELOOP_KQUEUE)
-	if (new_max_sock >= eloop.max_fd) {
+	if (new_max_sock >= eloop->max_fd) {
 		next = new_max_sock + 16;
-		temp_table = os_realloc_array(eloop.fd_table, next,
+		temp_table = os_realloc_array(eloop->fd_table, next,
 					      sizeof(struct eloop_sock));
 		if (temp_table == NULL)
 			return -1;
 
-		eloop.max_fd = next;
-		eloop.fd_table = temp_table;
+		eloop->max_fd = next;
+		eloop->fd_table = temp_table;
 	}
 #endif /* CONFIG_ELOOP_EPOLL || CONFIG_ELOOP_KQUEUE */
 
 #ifdef CONFIG_ELOOP_EPOLL
-	if (eloop.count + 1 > eloop.epoll_max_event_num) {
-		next = eloop.epoll_max_event_num == 0 ? 8 :
-			eloop.epoll_max_event_num * 2;
-		temp_events = os_realloc_array(eloop.epoll_events, next,
+	if (eloop->count + 1 > eloop->epoll_max_event_num) {
+		next = eloop->epoll_max_event_num == 0 ? 8 :
+			eloop->epoll_max_event_num * 2;
+		temp_events = os_realloc_array(eloop->epoll_events, next,
 					       sizeof(struct epoll_event));
 		if (temp_events == NULL) {
 			log_errno("eloop_sock_table_add_sock: malloc for epoll failed");
 			return -1;
 		}
 
-		eloop.epoll_max_event_num = next;
-		eloop.epoll_events = temp_events;
+		eloop->epoll_max_event_num = next;
+		eloop->epoll_events = temp_events;
 	}
 #endif /* CONFIG_ELOOP_EPOLL */
 #ifdef CONFIG_ELOOP_KQUEUE
-	if (eloop.count + 1 > eloop.kqueue_nevents) {
-		next = eloop.kqueue_nevents == 0 ? 8 : eloop.kqueue_nevents * 2;
+	if (eloop->count + 1 > eloop->kqueue_nevents) {
+		next = eloop->kqueue_nevents == 0 ? 8 : eloop->kqueue_nevents * 2;
 		temp_events = os_malloc(next * sizeof(*temp_events));
 		if (!temp_events) {
 			log_errno(
@@ -347,9 +261,9 @@ static int eloop_sock_table_add_sock(struct eloop_sock_table *table,
 			return -1;
 		}
 
-		os_free(eloop.kqueue_events);
-		eloop.kqueue_events = temp_events;
-		eloop.kqueue_nevents = next;
+		os_free(eloop->kqueue_events);
+		eloop->kqueue_events = temp_events;
+		eloop->kqueue_nevents = next;
 	}
 #endif /* CONFIG_ELOOP_KQUEUE */
 
@@ -368,22 +282,23 @@ static int eloop_sock_table_add_sock(struct eloop_sock_table *table,
 	wpa_trace_record(&tmp[table->count]);
 	table->count++;
 	table->table = tmp;
-	eloop.max_sock = new_max_sock;
-	eloop.count++;
+	eloop->max_sock = new_max_sock;
+	eloop->count++;
 	table->changed = 1;
 	eloop_trace_sock_add_ref(table);
 
 #if defined(CONFIG_ELOOP_EPOLL) || defined(CONFIG_ELOOP_KQUEUE)
-	if (eloop_sock_queue(sock, table->type) < 0)
+	if (eloop_sock_queue(eloop, sock, table->type) < 0)
 		return -1;
-	os_memcpy(&eloop.fd_table[sock], &table->table[table->count - 1],
+	os_memcpy(&eloop->fd_table[sock], &table->table[table->count - 1],
 		  sizeof(struct eloop_sock));
 #endif /* CONFIG_ELOOP_EPOLL || CONFIG_ELOOP_KQUEUE */
 	return 0;
 }
 
 
-static void eloop_sock_table_remove_sock(struct eloop_sock_table *table,
+static void eloop_sock_table_remove_sock(struct eloop_data *eloop,
+                                         struct eloop_sock_table *table,
                                          int sock)
 {
 #ifdef CONFIG_ELOOP_KQUEUE
@@ -400,6 +315,7 @@ static void eloop_sock_table_remove_sock(struct eloop_sock_table *table,
 	}
 	if (i == table->count)
 		return;
+
 	eloop_trace_sock_remove_ref(table);
 	if (i != table->count - 1) {
 		os_memmove(&table->table[i], &table->table[i + 1],
@@ -407,24 +323,24 @@ static void eloop_sock_table_remove_sock(struct eloop_sock_table *table,
 			   sizeof(struct eloop_sock));
 	}
 	table->count--;
-	eloop.count--;
+	eloop->count--;
 	table->changed = 1;
 	eloop_trace_sock_add_ref(table);
 #ifdef CONFIG_ELOOP_EPOLL
-	if (epoll_ctl(eloop.epollfd, EPOLL_CTL_DEL, sock, NULL) < 0) {
+	if (epoll_ctl(eloop->epollfd, EPOLL_CTL_DEL, sock, NULL) < 0) {
 		log_errno("eloop_sock_table_remove_sock: epoll_ctl(DEL) for fd=%d failed", sock);
 		return;
 	}
-	os_memset(&eloop.fd_table[sock], 0, sizeof(struct eloop_sock));
+	os_memset(&eloop->fd_table[sock], 0, sizeof(struct eloop_sock));
 #endif /* CONFIG_ELOOP_EPOLL */
 #ifdef CONFIG_ELOOP_KQUEUE
 	EV_SET(&ke, sock, event_type_kevent_filter(table->type), EV_DELETE, 0,
 	       0, 0);
-	if (kevent(eloop.kqueuefd, &ke, 1, NULL, 0, NULL) < 0) {
+	if (kevent(eloop->kqueuefd, &ke, 1, NULL, 0, NULL) < 0) {
 		log_errno("eloop_sock_table_remove_sock: kevent(DEL) for fd=%d failed", sock);
 		return;
 	}
-	os_memset(&eloop.fd_table[sock], 0, sizeof(struct eloop_sock));
+	os_memset(&eloop->fd_table[sock], 0, sizeof(struct eloop_sock));
 #endif /* CONFIG_ELOOP_KQUEUE */
 }
 
@@ -516,7 +432,7 @@ static int eloop_sock_table_set_fds(struct eloop_sock_table *readers,
 }
 
 
-static int eloop_sock_table_dispatch_table(struct eloop_sock_table *table,
+static int eloop_sock_table_dispatch_table(struct eloop_data *eloop, struct eloop_sock_table *table,
 					   struct pollfd **pollfds_map,
 					   int max_pollfd_map,
 					   short int revents)
@@ -548,22 +464,22 @@ static int eloop_sock_table_dispatch_table(struct eloop_sock_table *table,
 }
 
 
-static void eloop_sock_table_dispatch(struct eloop_sock_table *readers,
+static void eloop_sock_table_dispatch(struct eloop_data *eloop, struct eloop_sock_table *readers,
 				      struct eloop_sock_table *writers,
 				      struct eloop_sock_table *exceptions,
 				      struct pollfd **pollfds_map,
 				      int max_pollfd_map)
 {
-	if (eloop_sock_table_dispatch_table(readers, pollfds_map,
+	if (eloop_sock_table_dispatch_table(eloop, readers, pollfds_map,
 					    max_pollfd_map, POLLIN | POLLERR |
 					    POLLHUP))
 		return; /* pollfds may be invalid at this point */
 
-	if (eloop_sock_table_dispatch_table(writers, pollfds_map,
+	if (eloop_sock_table_dispatch_table(eloop, writers, pollfds_map,
 					    max_pollfd_map, POLLOUT))
 		return; /* pollfds may be invalid at this point */
 
-	eloop_sock_table_dispatch_table(exceptions, pollfds_map,
+	eloop_sock_table_dispatch_table(eloop, exceptions, pollfds_map,
 					max_pollfd_map, POLLERR | POLLHUP);
 }
 
@@ -588,9 +504,10 @@ static void eloop_sock_table_set_fds(struct eloop_sock_table *table,
 }
 
 
-static void eloop_sock_table_dispatch(struct eloop_sock_table *table,
+static void eloop_sock_table_dispatch(struct eloop_data *eloop, struct eloop_sock_table *table,
 				      fd_set *fds)
 {
+	(void) eloop; //unused
 	size_t i;
 
 	if (table == NULL || table->table == NULL)
@@ -612,20 +529,20 @@ static void eloop_sock_table_dispatch(struct eloop_sock_table *table,
 
 
 #ifdef CONFIG_ELOOP_EPOLL
-static void eloop_sock_table_dispatch(struct epoll_event *events, int nfds)
+static void eloop_sock_table_dispatch(struct eloop_data *eloop, struct epoll_event *events, int nfds)
 {
 	struct eloop_sock *table;
 	int i;
 
 	for (i = 0; i < nfds; i++) {
-		table = &eloop.fd_table[events[i].data.fd];
+		table = &eloop->fd_table[events[i].data.fd];
 		if (table->handler == NULL)
 			continue;
 		table->handler(table->sock, table->eloop_data,
 			       table->user_data);
-		if (eloop.readers.changed ||
-		    eloop.writers.changed ||
-		    eloop.exceptions.changed)
+		if (eloop->readers.changed ||
+		    eloop->writers.changed ||
+		    eloop->exceptions.changed)
 			break;
 	}
 }
@@ -634,33 +551,33 @@ static void eloop_sock_table_dispatch(struct epoll_event *events, int nfds)
 
 #ifdef CONFIG_ELOOP_KQUEUE
 
-static void eloop_sock_table_dispatch(struct kevent *events, int nfds)
+static void eloop_sock_table_dispatch(struct eloop_data *eloop, struct kevent *events, int nfds)
 {
 	struct eloop_sock *table;
 	int i;
 
 	for (i = 0; i < nfds; i++) {
-		table = &eloop.fd_table[events[i].ident];
+		table = &eloop->fd_table[events[i].ident];
 		if (table->handler == NULL)
 			continue;
 		table->handler(table->sock, table->eloop_data,
 			       table->user_data);
-		if (eloop.readers.changed ||
-		    eloop.writers.changed ||
-		    eloop.exceptions.changed)
+		if (eloop->readers.changed ||
+		    eloop->writers.changed ||
+		    eloop->exceptions.changed)
 			break;
 	}
 }
 
 
-static int eloop_sock_table_requeue(struct eloop_sock_table *table)
+static int eloop_sock_table_requeue(struct eloop_data *eloop, struct eloop_sock_table *table)
 {
 	size_t i;
 	int r;
 
 	r = 0;
 	for (i = 0; i < table->count && table->table; i++) {
-		if (eloop_sock_queue(table->table[i].sock, table->type) == -1)
+		if (eloop_sock_queue(eloop, table->table[i].sock, table->type) == -1)
 			r = -1;
 	}
 	return r;
@@ -669,24 +586,26 @@ static int eloop_sock_table_requeue(struct eloop_sock_table *table)
 #endif /* CONFIG_ELOOP_KQUEUE */
 
 
-int eloop_sock_requeue(void)
+int eloop_sock_requeue(struct eloop_data *eloop)
 {
 	int r = 0;
 
 #ifdef CONFIG_ELOOP_KQUEUE
-	close(eloop.kqueuefd);
-	eloop.kqueuefd = kqueue();
-	if (eloop.kqueuefd < 0) {
+	close(eloop->kqueuefd);
+	eloop->kqueuefd = kqueue();
+	if (eloop->kqueuefd < 0) {
 		log_errno("eloop_sock_requeue: kqueue failed");
 		return -1;
 	}
 
-	if (eloop_sock_table_requeue(&eloop.readers) < 0)
+	if (eloop_sock_table_requeue(eloop, &eloop->readers) < 0)
 		r = -1;
-	if (eloop_sock_table_requeue(&eloop.writers) < 0)
+	if (eloop_sock_table_requeue(eloop, &eloop->writers) < 0)
 		r = -1;
-	if (eloop_sock_table_requeue(&eloop.exceptions) < 0)
+	if (eloop_sock_table_requeue(eloop, &eloop->exceptions) < 0)
 		r = -1;
+#else
+	(void) eloop; // unused
 #endif /* CONFIG_ELOOP_KQUEUE */
 
 	return r;
@@ -716,61 +635,74 @@ static void eloop_sock_table_destroy(struct eloop_sock_table *table)
 }
 
 
-int eloop_register_read_sock(int sock, eloop_sock_handler handler,
+int eloop_register_read_sock(struct eloop_data *eloop, int sock, eloop_sock_handler handler,
 			     void *eloop_data, void *user_data)
 {
-	return eloop_register_sock(sock, EVENT_TYPE_READ, handler,
+	return eloop_register_sock(eloop, sock, EVENT_TYPE_READ, handler,
 				   eloop_data, user_data);
 }
 
 
-void eloop_unregister_read_sock(int sock)
+void eloop_unregister_read_sock(struct eloop_data *eloop, int sock)
 {
-	eloop_unregister_sock(sock, EVENT_TYPE_READ);
+	eloop_unregister_sock(eloop, sock, EVENT_TYPE_READ);
 }
 
 
-static struct eloop_sock_table *eloop_get_sock_table(eloop_event_type type)
+static struct eloop_sock_table *eloop_get_sock_table(struct eloop_data *eloop, eloop_event_type type)
 {
+	if (eloop == NULL) {
+		log_info("eloop_get_sock_table: eloop data ptr was NULL");
+		return NULL;
+	}
 	switch (type) {
 	case EVENT_TYPE_READ:
-		return &eloop.readers;
+		return &eloop->readers;
 	case EVENT_TYPE_WRITE:
-		return &eloop.writers;
+		return &eloop->writers;
 	case EVENT_TYPE_EXCEPTION:
-		return &eloop.exceptions;
+		return &eloop->exceptions;
 	}
 
 	return NULL;
 }
 
 
-int eloop_register_sock(int sock, eloop_event_type type,
+int eloop_register_sock(struct eloop_data *eloop, int sock, eloop_event_type type,
 			eloop_sock_handler handler,
 			void *eloop_data, void *user_data)
 {
+	if (eloop == NULL) {
+		log_error("eloop param is NULL");
+		return -1;
+	}
 	struct eloop_sock_table *table;
 
 	assert(sock >= 0);
-	table = eloop_get_sock_table(type);
-	return eloop_sock_table_add_sock(table, sock, handler,
+	table = eloop_get_sock_table(eloop, type);
+	return eloop_sock_table_add_sock(eloop, table, sock, handler,
 					 eloop_data, user_data);
 }
 
 
-void eloop_unregister_sock(int sock, eloop_event_type type)
+void eloop_unregister_sock(struct eloop_data *eloop, int sock, eloop_event_type type)
 {
 	struct eloop_sock_table *table;
 
-	table = eloop_get_sock_table(type);
-	eloop_sock_table_remove_sock(table, sock);
+	table = eloop_get_sock_table(eloop, type);
+	eloop_sock_table_remove_sock(eloop, table, sock);
 }
 
 
-int eloop_register_timeout(unsigned int secs, unsigned int usecs,
+int eloop_register_timeout(struct eloop_data *eloop, unsigned int secs, unsigned int usecs,
 			   eloop_timeout_handler handler,
 			   void *eloop_data, void *user_data)
 {
+	if (eloop == NULL) {
+		log_error("eloop param is NULL");
+		return -1;
+	}
+
 	struct eloop_timeout *timeout, *tmp;
 	os_time_t now_sec;
 
@@ -800,13 +732,13 @@ int eloop_register_timeout(unsigned int secs, unsigned int usecs,
 	wpa_trace_record(timeout);
 
 	/* Maintain timeouts in order of increasing time */
-	dl_list_for_each(tmp, &eloop.timeout, struct eloop_timeout, list) {
+	dl_list_for_each(tmp, &eloop->timeout, struct eloop_timeout, list) {
 		if (os_reltime_before(&timeout->time, &tmp->time)) {
 			dl_list_add(tmp->list.prev, &timeout->list);
 			return 0;
 		}
 	}
-	dl_list_add_tail(&eloop.timeout, &timeout->list);
+	dl_list_add_tail(&eloop->timeout, &timeout->list);
 
 	return 0;
 
@@ -832,13 +764,18 @@ static void eloop_remove_timeout(struct eloop_timeout *timeout)
 }
 
 
-int eloop_cancel_timeout(eloop_timeout_handler handler,
+int eloop_cancel_timeout(struct eloop_data *eloop, eloop_timeout_handler handler,
 			 void *eloop_data, void *user_data)
 {
+	if (eloop == NULL) {
+		log_error("eloop param is NULL");
+		return -1;
+	}
+
 	struct eloop_timeout *timeout, *prev;
 	int removed = 0;
 
-	dl_list_for_each_safe(timeout, prev, &eloop.timeout,
+	dl_list_for_each_safe(timeout, prev, &eloop->timeout,
 			      struct eloop_timeout, list) {
 		if (timeout->handler == handler &&
 		    (timeout->eloop_data == eloop_data ||
@@ -854,10 +791,15 @@ int eloop_cancel_timeout(eloop_timeout_handler handler,
 }
 
 
-int eloop_cancel_timeout_one(eloop_timeout_handler handler,
+int eloop_cancel_timeout_one(struct eloop_data *eloop, eloop_timeout_handler handler,
 			     void *eloop_data, void *user_data,
 			     struct os_reltime *remaining)
 {
+	if (eloop == NULL) {
+		log_error("eloop param is NULL");
+		return -1;
+	}
+
 	struct eloop_timeout *timeout, *prev;
 	int removed = 0;
 	struct os_reltime now;
@@ -865,7 +807,7 @@ int eloop_cancel_timeout_one(eloop_timeout_handler handler,
 	os_get_reltime(&now);
 	remaining->sec = remaining->usec = 0;
 
-	dl_list_for_each_safe(timeout, prev, &eloop.timeout,
+	dl_list_for_each_safe(timeout, prev, &eloop->timeout,
 			      struct eloop_timeout, list) {
 		if (timeout->handler == handler &&
 		    (timeout->eloop_data == eloop_data) &&
@@ -881,12 +823,16 @@ int eloop_cancel_timeout_one(eloop_timeout_handler handler,
 }
 
 
-int eloop_is_timeout_registered(eloop_timeout_handler handler,
+int eloop_is_timeout_registered(struct eloop_data *eloop, eloop_timeout_handler handler,
 				void *eloop_data, void *user_data)
 {
+	if (eloop == NULL) {
+		log_error("eloop param is NULL");
+		return -1;
+	}
 	struct eloop_timeout *tmp;
 
-	dl_list_for_each(tmp, &eloop.timeout, struct eloop_timeout, list) {
+	dl_list_for_each(tmp, &eloop->timeout, struct eloop_timeout, list) {
 		if (tmp->handler == handler &&
 		    tmp->eloop_data == eloop_data &&
 		    tmp->user_data == user_data)
@@ -897,14 +843,19 @@ int eloop_is_timeout_registered(eloop_timeout_handler handler,
 }
 
 
-int eloop_deplete_timeout(unsigned int req_secs, unsigned int req_usecs,
+int eloop_deplete_timeout(struct eloop_data *eloop, unsigned int req_secs, unsigned int req_usecs,
 			  eloop_timeout_handler handler, void *eloop_data,
 			  void *user_data)
 {
+	if (eloop == NULL) {
+		log_error("eloop param is NULL");
+		return -1;
+	}
+
 	struct os_reltime now, requested, remaining;
 	struct eloop_timeout *tmp;
 
-	dl_list_for_each(tmp, &eloop.timeout, struct eloop_timeout, list) {
+	dl_list_for_each(tmp, &eloop->timeout, struct eloop_timeout, list) {
 		if (tmp->handler == handler &&
 		    tmp->eloop_data == eloop_data &&
 		    tmp->user_data == user_data) {
@@ -913,9 +864,9 @@ int eloop_deplete_timeout(unsigned int req_secs, unsigned int req_usecs,
 			os_get_reltime(&now);
 			os_reltime_sub(&tmp->time, &now, &remaining);
 			if (os_reltime_before(&requested, &remaining)) {
-				eloop_cancel_timeout(handler, eloop_data,
+				eloop_cancel_timeout(eloop, handler, eloop_data,
 						     user_data);
-				eloop_register_timeout(requested.sec,
+				eloop_register_timeout(eloop, requested.sec,
 						       requested.usec,
 						       handler, eloop_data,
 						       user_data);
@@ -929,14 +880,19 @@ int eloop_deplete_timeout(unsigned int req_secs, unsigned int req_usecs,
 }
 
 
-int eloop_replenish_timeout(unsigned int req_secs, unsigned int req_usecs,
+int eloop_replenish_timeout(struct eloop_data *eloop, unsigned int req_secs, unsigned int req_usecs,
 			    eloop_timeout_handler handler, void *eloop_data,
 			    void *user_data)
 {
+	if (eloop == NULL) {
+		log_error("eloop param is NULL");
+		return -1;
+	}
+
 	struct os_reltime now, requested, remaining;
 	struct eloop_timeout *tmp;
 
-	dl_list_for_each(tmp, &eloop.timeout, struct eloop_timeout, list) {
+	dl_list_for_each(tmp, &eloop->timeout, struct eloop_timeout, list) {
 		if (tmp->handler == handler &&
 		    tmp->eloop_data == eloop_data &&
 		    tmp->user_data == user_data) {
@@ -945,9 +901,9 @@ int eloop_replenish_timeout(unsigned int req_secs, unsigned int req_usecs,
 			os_get_reltime(&now);
 			os_reltime_sub(&tmp->time, &now, &remaining);
 			if (os_reltime_before(&remaining, &requested)) {
-				eloop_cancel_timeout(handler, eloop_data,
+				eloop_cancel_timeout(eloop, handler, eloop_data,
 						     user_data);
-				eloop_register_timeout(requested.sec,
+				eloop_register_timeout(eloop, requested.sec,
 						       requested.usec,
 						       handler, eloop_data,
 						       user_data);
@@ -960,114 +916,13 @@ int eloop_replenish_timeout(unsigned int req_secs, unsigned int req_usecs,
 	return -1;
 }
 
-
-#ifndef CONFIG_NATIVE_WINDOWS
-static void eloop_handle_alarm(int sig)
+void eloop_run(struct eloop_data *eloop)
 {
-	wpa_printf(MSG_ERROR, "eloop: could not process SIGINT or SIGTERM in "
-		   "two seconds. Looks like there\n"
-		   "is a bug that ends up in a busy loop that "
-		   "prevents clean shutdown.\n"
-		   "Killing program forcefully.\n");
-	exit(1);
-}
-#endif /* CONFIG_NATIVE_WINDOWS */
-
-
-static void eloop_handle_signal(int sig)
-{
-	size_t i;
-
-#ifndef CONFIG_NATIVE_WINDOWS
-	if ((sig == SIGINT || sig == SIGTERM) && !eloop.pending_terminate) {
-		/* Use SIGALRM to break out from potential busy loops that
-		 * would not allow the program to be killed. */
-		eloop.pending_terminate = 1;
-		signal(SIGALRM, eloop_handle_alarm);
-		alarm(2);
-	}
-#endif /* CONFIG_NATIVE_WINDOWS */
-
-	eloop.signaled++;
-	for (i = 0; i < eloop.signal_count; i++) {
-		if (eloop.signals[i].sig == sig) {
-			eloop.signals[i].signaled++;
-			break;
-		}
-	}
-}
-
-
-static void eloop_process_pending_signals(void)
-{
-	size_t i;
-
-	if (eloop.signaled == 0)
+	if (eloop == NULL) {
+		log_error("eloop param is NULL");
 		return;
-	eloop.signaled = 0;
-
-	if (eloop.pending_terminate) {
-#ifndef CONFIG_NATIVE_WINDOWS
-		alarm(0);
-#endif /* CONFIG_NATIVE_WINDOWS */
-		eloop.pending_terminate = 0;
 	}
 
-	for (i = 0; i < eloop.signal_count; i++) {
-		if (eloop.signals[i].signaled) {
-			eloop.signals[i].signaled = 0;
-			eloop.signals[i].handler(eloop.signals[i].sig,
-						 eloop.signals[i].user_data);
-		}
-	}
-}
-
-
-int eloop_register_signal(int sig, eloop_signal_handler handler,
-			  void *user_data)
-{
-	struct eloop_signal *tmp;
-
-	tmp = os_realloc_array(eloop.signals, eloop.signal_count + 1,
-			       sizeof(struct eloop_signal));
-	if (tmp == NULL)
-		return -1;
-
-	tmp[eloop.signal_count].sig = sig;
-	tmp[eloop.signal_count].user_data = user_data;
-	tmp[eloop.signal_count].handler = handler;
-	tmp[eloop.signal_count].signaled = 0;
-	eloop.signal_count++;
-	eloop.signals = tmp;
-	signal(sig, eloop_handle_signal);
-
-	return 0;
-}
-
-
-int eloop_register_signal_terminate(eloop_signal_handler handler,
-				    void *user_data)
-{
-	int ret = eloop_register_signal(SIGINT, handler, user_data);
-	if (ret == 0)
-		ret = eloop_register_signal(SIGTERM, handler, user_data);
-	return ret;
-}
-
-
-int eloop_register_signal_reconfig(eloop_signal_handler handler,
-				   void *user_data)
-{
-#ifdef CONFIG_NATIVE_WINDOWS
-	return 0;
-#else /* CONFIG_NATIVE_WINDOWS */
-	return eloop_register_signal(SIGHUP, handler, user_data);
-#endif /* CONFIG_NATIVE_WINDOWS */
-}
-
-
-void eloop_run(void)
-{
 #ifdef CONFIG_ELOOP_POLL
 	int num_poll_fds;
 	int timeout_ms = 0;
@@ -1093,25 +948,12 @@ void eloop_run(void)
 		goto out;
 #endif /* CONFIG_ELOOP_SELECT */
 
-	while (!eloop.terminate &&
-	       (!dl_list_empty(&eloop.timeout) || eloop.readers.count > 0 ||
-		eloop.writers.count > 0 || eloop.exceptions.count > 0)) {
+	while (!eloop->terminate &&
+	       (!dl_list_empty(&eloop->timeout) || eloop->readers.count > 0 ||
+		eloop->writers.count > 0 || eloop->exceptions.count > 0)) {
 		struct eloop_timeout *timeout;
 
-		if (eloop.pending_terminate) {
-			/*
-			 * This may happen in some corner cases where a signal
-			 * is received during a blocking operation. We need to
-			 * process the pending signals and exit if requested to
-			 * avoid hitting the SIGALRM limit if the blocking
-			 * operation took more than two seconds.
-			 */
-			eloop_process_pending_signals();
-			if (eloop.terminate)
-				break;
-		}
-
-		timeout = dl_list_first(&eloop.timeout, struct eloop_timeout,
+		timeout = dl_list_first(&eloop->timeout, struct eloop_timeout,
 					list);
 		if (timeout) {
 			os_get_reltime(&now);
@@ -1134,33 +976,33 @@ void eloop_run(void)
 
 #ifdef CONFIG_ELOOP_POLL
 		num_poll_fds = eloop_sock_table_set_fds(
-			&eloop.readers, &eloop.writers, &eloop.exceptions,
-			eloop.pollfds, eloop.pollfds_map,
-			eloop.max_pollfd_map);
-		res = poll(eloop.pollfds, num_poll_fds,
+			&eloop->readers, &eloop->writers, &eloop->exceptions,
+			eloop->pollfds, eloop->pollfds_map,
+			eloop->max_pollfd_map);
+		res = poll(eloop->pollfds, num_poll_fds,
 			   timeout ? timeout_ms : -1);
 #endif /* CONFIG_ELOOP_POLL */
 #ifdef CONFIG_ELOOP_SELECT
-		eloop_sock_table_set_fds(&eloop.readers, rfds);
-		eloop_sock_table_set_fds(&eloop.writers, wfds);
-		eloop_sock_table_set_fds(&eloop.exceptions, efds);
-		res = select(eloop.max_sock + 1, rfds, wfds, efds,
+		eloop_sock_table_set_fds(&eloop->readers, rfds);
+		eloop_sock_table_set_fds(&eloop->writers, wfds);
+		eloop_sock_table_set_fds(&eloop->exceptions, efds);
+		res = select(eloop->max_sock + 1, rfds, wfds, efds,
 			     timeout ? &_tv : NULL);
 #endif /* CONFIG_ELOOP_SELECT */
 #ifdef CONFIG_ELOOP_EPOLL
-		if (eloop.count == 0) {
+		if (eloop->count == 0) {
 			res = 0;
 		} else {
-			res = epoll_wait(eloop.epollfd, eloop.epoll_events,
-					 eloop.count, timeout_ms);
+			res = epoll_wait(eloop->epollfd, eloop->epoll_events,
+					 eloop->count, timeout_ms);
 		}
 #endif /* CONFIG_ELOOP_EPOLL */
 #ifdef CONFIG_ELOOP_KQUEUE
-		if (eloop.count == 0) {
+		if (eloop->count == 0) {
 			res = 0;
 		} else {
-			res = kevent(eloop.kqueuefd, NULL, 0,
-				     eloop.kqueue_events, eloop.kqueue_nevents,
+			res = kevent(eloop->kqueuefd, NULL, 0,
+				     eloop->kqueue_events, eloop->kqueue_nevents,
 				     timeout ? &ts : NULL);
 		}
 #endif /* CONFIG_ELOOP_KQUEUE */
@@ -1182,15 +1024,12 @@ void eloop_run(void)
 			goto out;
 		}
 
-		eloop.readers.changed = 0;
-		eloop.writers.changed = 0;
-		eloop.exceptions.changed = 0;
-
-		eloop_process_pending_signals();
-
+		eloop->readers.changed = 0;
+		eloop->writers.changed = 0;
+		eloop->exceptions.changed = 0;
 
 		/* check if some registered timeouts have occurred */
-		timeout = dl_list_first(&eloop.timeout, struct eloop_timeout,
+		timeout = dl_list_first(&eloop->timeout, struct eloop_timeout,
 					list);
 		if (timeout) {
 			os_get_reltime(&now);
@@ -1208,9 +1047,9 @@ void eloop_run(void)
 		if (res <= 0)
 			continue;
 
-		if (eloop.readers.changed ||
-		    eloop.writers.changed ||
-		    eloop.exceptions.changed) {
+		if (eloop->readers.changed ||
+		    eloop->writers.changed ||
+		    eloop->exceptions.changed) {
 			 /*
 			  * Sockets may have been closed and reopened with the
 			  * same FD in the signal or timeout handlers, so we
@@ -1222,24 +1061,24 @@ void eloop_run(void)
 		}
 
 #ifdef CONFIG_ELOOP_POLL
-		eloop_sock_table_dispatch(&eloop.readers, &eloop.writers,
-					  &eloop.exceptions, eloop.pollfds_map,
-					  eloop.max_pollfd_map);
+		eloop_sock_table_dispatch(eloop, &eloop->readers, &eloop->writers,
+					  &eloop->exceptions, eloop->pollfds_map,
+					  eloop->max_pollfd_map);
 #endif /* CONFIG_ELOOP_POLL */
 #ifdef CONFIG_ELOOP_SELECT
-		eloop_sock_table_dispatch(&eloop.readers, rfds);
-		eloop_sock_table_dispatch(&eloop.writers, wfds);
-		eloop_sock_table_dispatch(&eloop.exceptions, efds);
+		eloop_sock_table_dispatch(eloop, &eloop->readers, rfds);
+		eloop_sock_table_dispatch(eloop, &eloop->writers, wfds);
+		eloop_sock_table_dispatch(eloop, &eloop->exceptions, efds);
 #endif /* CONFIG_ELOOP_SELECT */
 #ifdef CONFIG_ELOOP_EPOLL
-		eloop_sock_table_dispatch(eloop.epoll_events, res);
+		eloop_sock_table_dispatch(eloop, eloop->epoll_events, res);
 #endif /* CONFIG_ELOOP_EPOLL */
 #ifdef CONFIG_ELOOP_KQUEUE
-		eloop_sock_table_dispatch(eloop.kqueue_events, res);
+		eloop_sock_table_dispatch(eloop, eloop->kqueue_events, res);
 #endif /* CONFIG_ELOOP_KQUEUE */
 	}
 
-	eloop.terminate = 0;
+	eloop->terminate = 0;
 out:
 #ifdef CONFIG_ELOOP_SELECT
 	os_free(rfds);
@@ -1250,19 +1089,29 @@ out:
 }
 
 
-void eloop_terminate(void)
+void eloop_terminate(struct eloop_data *eloop)
 {
-	eloop.terminate = 1;
+	if (eloop == NULL) {
+		log_error("eloop param is NULL");
+		return;
+	}
+
+	eloop->terminate = 1;
 }
 
 
-void eloop_destroy(void)
+void eloop_destroy(struct eloop_data *eloop)
 {
+	if (eloop == NULL) {
+		log_error("eloop param is NULL");
+		return;
+	}
+
 	struct eloop_timeout *timeout, *prev;
 	struct os_reltime now;
 
 	os_get_reltime(&now);
-	dl_list_for_each_safe(timeout, prev, &eloop.timeout,
+	dl_list_for_each_safe(timeout, prev, &eloop->timeout,
 			      struct eloop_timeout, list) {
 		int sec, usec;
 		sec = timeout->time.sec - now.sec;
@@ -1280,32 +1129,45 @@ void eloop_destroy(void)
 		wpa_trace_dump("eloop timeout", timeout);
 		eloop_remove_timeout(timeout);
 	}
-	eloop_sock_table_destroy(&eloop.readers);
-	eloop_sock_table_destroy(&eloop.writers);
-	eloop_sock_table_destroy(&eloop.exceptions);
-	os_free(eloop.signals);
+	eloop_sock_table_destroy(&eloop->readers);
+	eloop_sock_table_destroy(&eloop->writers);
+	eloop_sock_table_destroy(&eloop->exceptions);
 
 #ifdef CONFIG_ELOOP_POLL
-	os_free(eloop.pollfds);
-	os_free(eloop.pollfds_map);
+	os_free(eloop->pollfds);
+	os_free(eloop->pollfds_map);
 #endif /* CONFIG_ELOOP_POLL */
 #if defined(CONFIG_ELOOP_EPOLL) || defined(CONFIG_ELOOP_KQUEUE)
-	os_free(eloop.fd_table);
+	os_free(eloop->fd_table);
 #endif /* CONFIG_ELOOP_EPOLL || CONFIG_ELOOP_KQUEUE */
 #ifdef CONFIG_ELOOP_EPOLL
-	os_free(eloop.epoll_events);
-	close(eloop.epollfd);
+	os_free(eloop->epoll_events);
+	close(eloop->epollfd);
 #endif /* CONFIG_ELOOP_EPOLL */
 #ifdef CONFIG_ELOOP_KQUEUE
-	os_free(eloop.kqueue_events);
-	close(eloop.kqueuefd);
+	os_free(eloop->kqueue_events);
+	close(eloop->kqueuefd);
 #endif /* CONFIG_ELOOP_KQUEUE */
 }
 
+void eloop_free(struct eloop_data *eloop) {
+  if (eloop == NULL) {
+    return;
+  }
 
-int eloop_terminated(void)
+  eloop_destroy(eloop);
+  os_free(eloop);
+}
+
+
+int eloop_terminated(struct eloop_data *eloop)
 {
-	return eloop.terminate || eloop.pending_terminate;
+	if (eloop == NULL) {
+		log_error("eloop param is NULL");
+		return -1;
+	}
+
+	return eloop->terminate;
 }
 
 
diff --git a/src/utils/eloop.h b/src/utils/eloop.h
index 6241beb..d38e2a9 100644
--- a/src/utils/eloop.h
+++ b/src/utils/eloop.h
@@ -22,6 +22,8 @@
  */
 #define ELOOP_ALL_CTX (void *) -1
 
+#include "trace.h"
+#include "list.h"
 #include "src/utils/os.h"
 
 /**
@@ -67,16 +69,124 @@ typedef void (*eloop_timeout_handler)(void *eloop_ctx, void *user_ctx);
  */
 typedef void (*eloop_signal_handler)(int sig, void *signal_ctx);
 
+#if defined(CONFIG_ELOOP_POLL) && defined(CONFIG_ELOOP_EPOLL)
+#error Do not define both of poll and epoll
+#endif
+
+#if defined(CONFIG_ELOOP_POLL) && defined(CONFIG_ELOOP_KQUEUE)
+#error Do not define both of poll and kqueue
+#endif
+
+#if !defined(CONFIG_ELOOP_POLL) && !defined(CONFIG_ELOOP_EPOLL) && \
+    !defined(CONFIG_ELOOP_KQUEUE)
+#define CONFIG_ELOOP_SELECT
+#endif
+
+#ifdef CONFIG_ELOOP_POLL
+#include <poll.h>
+#endif /* CONFIG_ELOOP_POLL */
+
+#ifdef CONFIG_ELOOP_EPOLL
+#include <sys/epoll.h>
+#endif /* CONFIG_ELOOP_EPOLL */
+
+#ifdef CONFIG_ELOOP_KQUEUE
+#include <sys/event.h>
+#endif /* CONFIG_ELOOP_KQUEUE */
+
+struct eloop_sock {
+	int sock;
+	void *eloop_data;
+	void *user_data;
+	eloop_sock_handler handler;
+	WPA_TRACE_REF(eloop);
+	WPA_TRACE_REF(user);
+	WPA_TRACE_INFO
+};
+
+struct eloop_timeout {
+	struct dl_list list;
+	struct os_reltime time;
+	void *eloop_data;
+	void *user_data;
+	eloop_timeout_handler handler;
+	WPA_TRACE_REF(eloop);
+	WPA_TRACE_REF(user);
+	WPA_TRACE_INFO
+};
+
+struct eloop_signal {
+	int sig;
+	void *user_data;
+	eloop_signal_handler handler;
+	int signaled;
+};
+
+struct eloop_sock_table {
+	size_t count;
+	struct eloop_sock *table;
+	eloop_event_type type;
+	int changed;
+};
+
+struct eloop_data {
+	int max_sock;
+
+	size_t count; /* sum of all table counts */
+#ifdef CONFIG_ELOOP_POLL
+	size_t max_pollfd_map; /* number of pollfds_map currently allocated */
+	size_t max_poll_fds; /* number of pollfds currently allocated */
+	struct pollfd *pollfds;
+	struct pollfd **pollfds_map;
+#endif /* CONFIG_ELOOP_POLL */
+#if defined(CONFIG_ELOOP_EPOLL) || defined(CONFIG_ELOOP_KQUEUE)
+	int max_fd;
+	struct eloop_sock *fd_table;
+#endif /* CONFIG_ELOOP_EPOLL || CONFIG_ELOOP_KQUEUE */
+#ifdef CONFIG_ELOOP_EPOLL
+	int epollfd;
+	size_t epoll_max_event_num;
+	struct epoll_event *epoll_events;
+#endif /* CONFIG_ELOOP_EPOLL */
+#ifdef CONFIG_ELOOP_KQUEUE
+	int kqueuefd;
+	size_t kqueue_nevents;
+	struct kevent *kqueue_events;
+#endif /* CONFIG_ELOOP_KQUEUE */
+	struct eloop_sock_table readers;
+	struct eloop_sock_table writers;
+	struct eloop_sock_table exceptions;
+
+	struct dl_list timeout;
+
+	// Removed, because in C, we can't use lambdas
+	// size_t signal_count;
+	// struct eloop_signal *signals;
+	// int signaled;
+	// int pending_terminate;
+
+	int terminate;
+};
+
 /**
  * eloop_init() - Initialize global event loop data
- * Returns: 0 on success, -1 on failure
+ * Returns: struct eloop_data on success, NULL on failure
  *
  * This function must be called before any other eloop_* function.
  */
-int eloop_init(void);
+struct eloop_data *eloop_init(void);
+
+/**
+ * eloop_free() - Free's the eloop context
+ * @eloop: eloop context
+ *
+ * This function must be called before any other eloop_* function.
+ */
+void eloop_free(struct eloop_data *eloop);
 
 /**
  * eloop_register_read_sock - Register handler for read events
+ * @eloop: eloop context
  * @sock: File descriptor number for the socket
  * @handler: Callback function to be called when data is available for reading
  * @eloop_data: Callback context data (eloop_ctx)
@@ -89,20 +199,23 @@ int eloop_init(void);
  * having processed it in order to avoid eloop from calling the handler again
  * for the same event.
  */
-int eloop_register_read_sock(int sock, eloop_sock_handler handler,
-			     void *eloop_data, void *user_data);
+int eloop_register_read_sock(struct eloop_data *eloop, int sock,
+                             eloop_sock_handler handler, void *eloop_data,
+                             void *user_data);
 
 /**
  * eloop_unregister_read_sock - Unregister handler for read events
+ * @eloop: eloop context
  * @sock: File descriptor number for the socket
  *
  * Unregister a read socket notifier that was previously registered with
  * eloop_register_read_sock().
  */
-void eloop_unregister_read_sock(int sock);
+void eloop_unregister_read_sock(struct eloop_data *eloop, int sock);
 
 /**
  * eloop_register_sock - Register handler for socket events
+ * @eloop: eloop context
  * @sock: File descriptor number for the socket
  * @type: Type of event to wait for
  * @handler: Callback function to be called when the event is triggered
@@ -116,22 +229,25 @@ void eloop_unregister_read_sock(int sock);
  * having processed it in order to avoid eloop from calling the handler again
  * for the same event.
  */
-int eloop_register_sock(int sock, eloop_event_type type,
-			eloop_sock_handler handler,
-			void *eloop_data, void *user_data);
+int eloop_register_sock(struct eloop_data *eloop, int sock,
+                        eloop_event_type type, eloop_sock_handler handler,
+                        void *eloop_data, void *user_data);
 
 /**
  * eloop_unregister_sock - Unregister handler for socket events
+ * @eloop: eloop context
  * @sock: File descriptor number for the socket
  * @type: Type of event for which sock was registered
  *
  * Unregister a socket event notifier that was previously registered with
  * eloop_register_sock().
  */
-void eloop_unregister_sock(int sock, eloop_event_type type);
+void eloop_unregister_sock(struct eloop_data *eloop, int sock,
+                           eloop_event_type type);
 
 /**
  * eloop_register_event - Register handler for generic events
+ * @eloop: eloop context
  * @event: Event to wait (eloop implementation specific)
  * @event_size: Size of event data
  * @handler: Callback function to be called when event is triggered
@@ -152,22 +268,25 @@ void eloop_unregister_sock(int sock, eloop_event_type type);
  * and they would call this function with eloop_register_event(h, sizeof(h),
  * ...).
  */
-int eloop_register_event(void *event, size_t event_size,
-			 eloop_event_handler handler,
-			 void *eloop_data, void *user_data);
+int eloop_register_event(struct eloop_data *eloop, void *event,
+                         size_t event_size, eloop_event_handler handler,
+                         void *eloop_data, void *user_data);
 
 /**
  * eloop_unregister_event - Unregister handler for a generic event
+ * @eloop: eloop context
  * @event: Event to cancel (eloop implementation specific)
  * @event_size: Size of event data
  *
  * Unregister a generic event notifier that was previously registered with
  * eloop_register_event().
  */
-void eloop_unregister_event(void *event, size_t event_size);
+void eloop_unregister_event(struct eloop_data *eloop, void *event,
+                            size_t event_size);
 
 /**
  * eloop_register_timeout - Register timeout
+ * @eloop: eloop context
  * @secs: Number of seconds to the timeout
  * @usecs: Number of microseconds to the timeout
  * @handler: Callback function to be called when timeout occurs
@@ -178,12 +297,13 @@ void eloop_unregister_event(void *event, size_t event_size);
  * Register a timeout that will cause the handler function to be called after
  * given time.
  */
-int eloop_register_timeout(unsigned int secs, unsigned int usecs,
-			   eloop_timeout_handler handler,
-			   void *eloop_data, void *user_data);
+int eloop_register_timeout(struct eloop_data *eloop, unsigned int secs,
+                           unsigned int usecs, eloop_timeout_handler handler,
+                           void *eloop_data, void *user_data);
 
 /**
  * eloop_cancel_timeout - Cancel timeouts
+ * @eloop: eloop context
  * @handler: Matching callback function
  * @eloop_data: Matching eloop_data or %ELOOP_ALL_CTX to match all
  * @user_data: Matching user_data or %ELOOP_ALL_CTX to match all
@@ -193,11 +313,13 @@ int eloop_register_timeout(unsigned int secs, unsigned int usecs,
  * eloop_register_timeout(). ELOOP_ALL_CTX can be used as a wildcard for
  * cancelling all timeouts regardless of eloop_data/user_data.
  */
-int eloop_cancel_timeout(eloop_timeout_handler handler,
-			 void *eloop_data, void *user_data);
+int eloop_cancel_timeout(struct eloop_data *eloop,
+                         eloop_timeout_handler handler, void *eloop_data,
+                         void *user_data);
 
 /**
  * eloop_cancel_timeout_one - Cancel a single timeout
+ * @eloop: eloop context
  * @handler: Matching callback function
  * @eloop_data: Matching eloop_data
  * @user_data: Matching user_data
@@ -207,12 +329,13 @@ int eloop_cancel_timeout(eloop_timeout_handler handler,
  * Cancel matching <handler,eloop_data,user_data> timeout registered with
  * eloop_register_timeout() and return the remaining time left.
  */
-int eloop_cancel_timeout_one(eloop_timeout_handler handler,
-			     void *eloop_data, void *user_data,
-			     struct os_reltime *remaining);
+int eloop_cancel_timeout_one(struct eloop_data *eloop,
+                             eloop_timeout_handler handler, void *eloop_data,
+                             void *user_data, struct os_reltime *remaining);
 
 /**
  * eloop_is_timeout_registered - Check if a timeout is already registered
+ * @eloop: eloop context
  * @handler: Matching callback function
  * @eloop_data: Matching eloop_data
  * @user_data: Matching user_data
@@ -221,11 +344,13 @@ int eloop_cancel_timeout_one(eloop_timeout_handler handler,
  * Determine if a matching <handler,eloop_data,user_data> timeout is registered
  * with eloop_register_timeout().
  */
-int eloop_is_timeout_registered(eloop_timeout_handler handler,
-				void *eloop_data, void *user_data);
+int eloop_is_timeout_registered(struct eloop_data *eloop,
+                                eloop_timeout_handler handler, void *eloop_data,
+                                void *user_data);
 
 /**
  * eloop_deplete_timeout - Deplete a timeout that is already registered
+ * @eloop: eloop context
  * @req_secs: Requested number of seconds to the timeout
  * @req_usecs: Requested number of microseconds to the timeout
  * @handler: Matching callback function
@@ -237,12 +362,14 @@ int eloop_is_timeout_registered(eloop_timeout_handler handler,
  * Find a registered matching <handler,eloop_data,user_data> timeout. If found,
  * deplete the timeout if remaining time is more than the requested time.
  */
-int eloop_deplete_timeout(unsigned int req_secs, unsigned int req_usecs,
-			  eloop_timeout_handler handler, void *eloop_data,
-			  void *user_data);
+int eloop_deplete_timeout(struct eloop_data *eloop, unsigned int req_secs,
+                          unsigned int req_usecs,
+                          eloop_timeout_handler handler, void *eloop_data,
+                          void *user_data);
 
 /**
  * eloop_replenish_timeout - Replenish a timeout that is already registered
+ * @eloop: eloop context
  * @req_secs: Requested number of seconds to the timeout
  * @req_usecs: Requested number of microseconds to the timeout
  * @handler: Matching callback function
@@ -254,101 +381,39 @@ int eloop_deplete_timeout(unsigned int req_secs, unsigned int req_usecs,
  * Find a registered matching <handler,eloop_data,user_data> timeout. If found,
  * replenish the timeout if remaining time is less than the requested time.
  */
-int eloop_replenish_timeout(unsigned int req_secs, unsigned int req_usecs,
-			    eloop_timeout_handler handler, void *eloop_data,
-			    void *user_data);
-
-/**
- * eloop_register_signal - Register handler for signals
- * @sig: Signal number (e.g., SIGHUP)
- * @handler: Callback function to be called when the signal is received
- * @user_data: Callback context data (signal_ctx)
- * Returns: 0 on success, -1 on failure
- *
- * Register a callback function that will be called when a signal is received.
- * The callback function is actually called only after the system signal
- * handler has returned. This means that the normal limits for sighandlers
- * (i.e., only "safe functions" allowed) do not apply for the registered
- * callback.
- */
-int eloop_register_signal(int sig, eloop_signal_handler handler,
-			  void *user_data);
-
-/**
- * eloop_register_signal_terminate - Register handler for terminate signals
- * @handler: Callback function to be called when the signal is received
- * @user_data: Callback context data (signal_ctx)
- * Returns: 0 on success, -1 on failure
- *
- * Register a callback function that will be called when a process termination
- * signal is received. The callback function is actually called only after the
- * system signal handler has returned. This means that the normal limits for
- * sighandlers (i.e., only "safe functions" allowed) do not apply for the
- * registered callback.
- *
- * This function is a more portable version of eloop_register_signal() since
- * the knowledge of exact details of the signals is hidden in eloop
- * implementation. In case of operating systems using signal(), this function
- * registers handlers for SIGINT and SIGTERM.
- */
-int eloop_register_signal_terminate(eloop_signal_handler handler,
-				    void *user_data);
-
-/**
- * eloop_register_signal_reconfig - Register handler for reconfig signals
- * @handler: Callback function to be called when the signal is received
- * @user_data: Callback context data (signal_ctx)
- * Returns: 0 on success, -1 on failure
- *
- * Register a callback function that will be called when a reconfiguration /
- * hangup signal is received. The callback function is actually called only
- * after the system signal handler has returned. This means that the normal
- * limits for sighandlers (i.e., only "safe functions" allowed) do not apply
- * for the registered callback.
- *
- * This function is a more portable version of eloop_register_signal() since
- * the knowledge of exact details of the signals is hidden in eloop
- * implementation. In case of operating systems using signal(), this function
- * registers a handler for SIGHUP.
- */
-int eloop_register_signal_reconfig(eloop_signal_handler handler,
-				   void *user_data);
+int eloop_replenish_timeout(struct eloop_data *eloop, unsigned int req_secs,
+                            unsigned int req_usecs,
+                            eloop_timeout_handler handler, void *eloop_data,
+                            void *user_data);
 
 /**
  * eloop_sock_requeue - Requeue sockets
- *
+ * @eloop: eloop context
  * Requeue sockets after forking because some implementations require this,
  * such as epoll and kqueue.
  */
-int eloop_sock_requeue(void);
+int eloop_sock_requeue(struct eloop_data *eloop);
 
 /**
  * eloop_run - Start the event loop
- *
+ * @eloop: eloop context
  * Start the event loop and continue running as long as there are any
  * registered event handlers. This function is run after event loop has been
  * initialized with event_init() and one or more events have been registered.
  */
-void eloop_run(void);
+void eloop_run(struct eloop_data *eloop);
 
 /**
  * eloop_terminate - Terminate event loop
- *
+ * @eloop: eloop context
  * Terminate event loop even if there are registered events. This can be used
  * to request the program to be terminated cleanly.
  */
-void eloop_terminate(void);
-
-/**
- * eloop_destroy - Free any resources allocated for the event loop
- *
- * After calling eloop_destroy(), other eloop_* functions must not be called
- * before re-running eloop_init().
- */
-void eloop_destroy(void);
+void eloop_terminate(struct eloop_data *eloop);
 
 /**
  * eloop_terminated - Check whether event loop has been terminated
+ * @eloop: eloop context
  * Returns: 1 = event loop terminate, 0 = event loop still running
  *
  * This function can be used to check whether eloop_terminate() has been called
@@ -356,10 +421,11 @@ void eloop_destroy(void);
  * operations that may still be queued to be run when eloop_terminate() was
  * called.
  */
-int eloop_terminated(void);
+int eloop_terminated(struct eloop_data *eloop);
 
 /**
  * eloop_wait_for_read_sock - Wait for a single reader
+ *
  * @sock: File descriptor number for the socket
  *
  * Do a blocking wait for a single read socket.
-- 
2.25.1

